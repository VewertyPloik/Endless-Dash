<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Endless Dash</title>
<style>
  body {
    margin:0; padding:0; overflow:hidden;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d);
    color: white;
    user-select: none;
  }
  #game {
    position: relative;
    width: 100vw; height: 100vh;
    overflow: hidden;
    background: #222;
  }
  #player {
    position: absolute;
    font-size: 48px;
    left: 100px;
    bottom: 100px;
    user-select: none;
  }
  .spike, .forcefield, .heli {
    position: absolute;
    font-size: 40px;
    user-select: none;
  }
  .spike {
    bottom: 100px;
    color: red;
  }
  .forcefield {
    bottom: 140px;
    color: cyan;
  }
  .heli {
    bottom: 220px; /* Lower helicopter as requested */
  }
  #scoreboard {
    position: fixed;
    top: 10px; left: 10px;
    font-size: 22px;
    z-index: 10;
  }
  #jumpBtn {
    position: fixed;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    padding: 12px 24px;
    background: #007bff;
    border: none;
    border-radius: 12px;
    color: white;
    user-select: none;
    z-index: 10;
  }
  #skinBtn {
    position: fixed;
    top: 10px; right: 10px;
    font-size: 20px;
    padding: 8px 16px;
    background: #444;
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    z-index: 10;
  }
  #skinPopup {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #333;
    border: 2px solid white;
    padding: 20px;
    display: none;
    z-index: 20;
    border-radius: 12px;
    text-align: center;
  }
  #skinPopup span {
    cursor: pointer;
    font-size: 36px;
    margin: 8px;
    padding: 8px;
    display: inline-block;
    border: 2px solid transparent;
    user-select: none;
  }
  #skinPopup span.selected {
    border-color: lime;
  }
  #skinPopup button {
    margin-top: 12px;
    padding: 6px 12px;
    font-size: 18px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="game">
  <div id="player">🟦</div>
  <div id="scoreboard">Score: 0  HS: 0</div>
  <button id="jumpBtn">JUMP</button>
  <button id="skinBtn">Change Skin</button>

  <div id="skinPopup">
    <div>Select Your Skin</div>
    <div id="skinOptions"></div>
    <button id="closeSkin">Close</button>
  </div>
</div>

<script>
  const game = document.getElementById('game');
  const player = document.getElementById('player');
  const scoreDisplay = document.getElementById('scoreboard');
  const jumpBtn = document.getElementById('jumpBtn');
  const skinBtn = document.getElementById('skinBtn');
  const skinPopup = document.getElementById('skinPopup');
  const skinOptionsDiv = document.getElementById('skinOptions');
  const closeSkinBtn = document.getElementById('closeSkin');

  const skins = ['🟦','🟥','🟪','🟧','🟨','🟩','🟫'];

  let selectedSkin = localStorage.getItem('selectedSkin') || '🟦';
  player.textContent = selectedSkin;

  let jumping = false;
  let forceFieldActive = false;
  let score = 0;
  let highScore = localStorage.getItem('highScore') || 0;
  let speed = 4;
  let lastSpeedIncrease = performance.now();
  let alive = true;

  let velocityY = 0;
  const gravity = 1.2;
  const jumpPower = -20;
  const groundY = 100;

  // Arrays to hold obstacle/forcefield/helicopter elements and data
  const spikes = [];
  const forcefields = [];
  const helicopters = [];

  // Initialize skins popup
  function initSkins() {
    skinOptionsDiv.innerHTML = '';
    skins.forEach(skin => {
      const span = document.createElement('span');
      span.textContent = skin;
      if (skin === selectedSkin) span.classList.add('selected');
      span.onclick = () => {
        selectedSkin = skin;
        player.textContent = skin;
        localStorage.setItem('selectedSkin', skin);
        document.querySelectorAll('#skinOptions span').forEach(el => el.classList.remove('selected'));
        span.classList.add('selected');
      };
      skinOptionsDiv.appendChild(span);
    });
  }

  skinBtn.onclick = () => {
    skinPopup.style.display = 'block';
  };

  closeSkinBtn.onclick = () => {
    skinPopup.style.display = 'none';
  };

  // Create a spike element far to the right
  function createSpike() {
    const spike = document.createElement('div');
    spike.className = 'spike';
    spike.textContent = '^';
    spike.style.left = (window.innerWidth + 200 + Math.random() * 400) + 'px';
    spike.style.bottom = groundY + 'px';
    game.appendChild(spike);
    spikes.push(spike);
  }

  // Create a force field orb
  function createForceField() {
    const orb = document.createElement('div');
    orb.className = 'forcefield';
    orb.textContent = '⭕️';
    orb.style.left = (window.innerWidth + 500 + Math.random() * 600) + 'px';
    orb.style.bottom = (groundY + 40) + 'px';
    game.appendChild(orb);
    forcefields.push(orb);
  }

  // Create helicopter flying right to left, lower altitude
  function createHelicopter() {
    const heli = document.createElement('div');
    heli.className = 'heli';
    heli.textContent = '🚁';
    heli.style.left = window.innerWidth + 'px';
    heli.style.bottom = (groundY + 120) + 'px'; // medium distance down
    game.appendChild(heli);
    helicopters.push(heli);
  }

  // Remove offscreen elements
  function cleanupOffscreen() {
    spikes.forEach((spike, i) => {
      if (parseFloat(spike.style.left) < -50) {
        spike.remove();
        spikes.splice(i,1);
      }
    });
    forcefields.forEach((orb, i) => {
      if (parseFloat(orb.style.left) < -50) {
        orb.remove();
        forcefields.splice(i,1);
      }
    });
    helicopters.forEach((heli, i) => {
      if (parseFloat(heli.style.left) < -100) {
        heli.remove();
        helicopters.splice(i,1);
      }
    });
  }

  // Check collision between player and element
  function isColliding(el) {
    const pRect = player.getBoundingClientRect();
    const eRect = el.getBoundingClientRect();
    return !(
      pRect.right < eRect.left ||
      pRect.left > eRect.right ||
      pRect.bottom < eRect.top ||
      pRect.top > eRect.bottom
    );
  }

  // Jump logic
  function jump() {
    if (!jumping && alive) {
      velocityY = jumpPower;
      jumping = true;
    }
  }

  jumpBtn.onclick = jump;

  window.addEventListener('keydown', e => {
    if ((e.code === 'Space' || e.code === 'ArrowUp') && !jumping && alive) {
      jump();
    }
  });

  // Game over handling
  function gameOver() {
    alive = false;
    if(score > highScore) {
      highScore = score;
      localStorage.setItem('highScore', highScore);
    }
    scoreDisplay();
    alert(`Game Over!\nScore: ${score}\nHigh Score: ${highScore}`);
    resetGame();
  }

  // Score display update
  function scoreDisplay() {
    scoreDisplay.textContent = `Score: ${score}  HS: ${highScore}`;
  }

  // Reset game
  function resetGame() {
    // Remove all obstacles/items
    spikes.forEach(spike => spike.remove());
    forcefields.forEach(orb => orb.remove());
    helicopters.forEach(heli => heli.remove());
    spikes.length = 0;
    forcefields.length = 0;
    helicopters.length = 0;

    // Reset player
    player.style.bottom = groundY + 'px';
    jumping = false;
    forceFieldActive = false;
    velocityY = 0;
    score = 0;
    speed = 4;
    alive = true;
    lastSpeedIncrease = performance.now();
  }

  // Main game loop
  function gameLoop(timestamp) {
    if (!alive) return;

    // Move player vertically with gravity
    velocityY += gravity;
    let currentBottom = parseFloat(player.style.bottom) || groundY;
    currentBottom -= velocityY;

    if (currentBottom <= groundY) {
      currentBottom = groundY;
      jumping = false;
      velocityY = 0;
    }
    player.style.bottom = currentBottom + 'px';

    // Move obstacles/items/helicopters leftwards
    spikes.forEach(spike => {
      spike.style.left = (parseFloat(spike.style.left) - speed) + 'px';

      if (isColliding(spike)) {
        if (forceFieldActive) {
          forceFieldActive = false;
          spike.remove();
          spikes.splice(spikes.indexOf(spike), 1);
        } else {
          gameOver();
        }
      }
    });

    forcefields.forEach(orb => {
      orb.style.left = (parseFloat(orb.style.left) - speed) + 'px';
      if (isColliding(orb)) {
        forceFieldActive = true;
        orb.remove();
        forcefields.splice(forcefields.indexOf(orb), 1);
      }
    });

    helicopters.forEach(heli => {
      heli.style.left = (parseFloat(heli.style.left) - speed) + 'px';
      if (isColliding(heli)) {
        // Lift player above spikes for 6.2 seconds
        velocityY = 0;
        player.style.bottom = (groundY + 140) + 'px';
        setTimeout(() => {
          player.style.bottom = groundY + 'px';
        }, 6200);
        heli.remove();
        helicopters.splice(helicopters.indexOf(heli), 1);
      }
    });

    cleanupOffscreen();

    // Increase speed every 5 seconds
    if (performance.now() - lastSpeedIncrease > 5000) {
      speed *= 1.05;
      lastSpeedIncrease = performance.now();
    }

    // Randomly spawn obstacles/items/helicopters if less than limit
    if (spikes.length < 2 && Math.random() < 0.02) createSpike();
    if (forcefields.length < 1 && Math.random() < 0.005) createForceField();
    if (helicopters.length < 1 && Math.random() < 0.002) createHelicopter();

    // Increase score and update display
    score++;
    scoreDisplay();

    requestAnimationFrame(gameLoop);
  }

  // Start the game initially
  resetGame();
  initSkins();

  gameLoop();

</script>

</body>
</html>
