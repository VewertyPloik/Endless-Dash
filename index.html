<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Endless Dash</title>
<style>
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    font-family: Arial, sans-serif;
    background: #222;
    color: white;
    overflow: hidden;
    user-select: none;
  }
  #gameCanvas {
    background: #111;
    display: block;
    margin: 0 auto;
    border: 3px solid #555;
  }
  #jumpButton {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: #007bff;
    color: white;
    font-size: 2.5rem;
    padding: 15px 40px;
    border: none;
    border-radius: 15px;
    display: none;
    z-index: 10;
    user-select: none;
  }
  #homeScreen, #gameOverScreen {
    position: fixed;
    top:0; left:0; width:100%; height:100%;
    background: #111;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 20px;
    z-index: 20;
  }
  #homeScreen button, #gameOverScreen button {
    font-size: 1.5rem;
    padding: 10px 30px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
  }
  #scoreDisplay {
    position: fixed;
    top: 15px;
    left: 15px;
    font-size: 1.2rem;
    font-weight: bold;
    z-index: 15;
  }
</style>
</head>
<body>

<div id="homeScreen">
  <h1>Endless Dash</h1>
  <button id="startBtn">Start Game</button>
</div>

<div id="gameOverScreen" style="display:none;">
  <h1>Game Over</h1>
  <p id="finalScore"></p>
  <p id="highScoreText"></p>
  <button id="returnHomeBtn">Return Home</button>
</div>

<div id="scoreDisplay" style="display:none;">Score: 0</div>

<button id="jumpButton">JUMP</button>

<canvas id="gameCanvas" width="600" height="300"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const homeScreen = document.getElementById('homeScreen');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const finalScoreText = document.getElementById('finalScore');
  const highScoreText = document.getElementById('highScoreText');
  const returnHomeBtn = document.getElementById('returnHomeBtn');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const jumpButton = document.getElementById('jumpButton');

  const W = canvas.width;
  const H = canvas.height;

  // Game constants
  const GRAVITY = 0.6;
  const FLOOR_Y = H - 50;
  const PLAYER_SIZE = 30;
  const JUMP_VEL = -12;
  const SPAWN_INTERVAL = 90; // frames between spikes/helicopters approx
  const HELICOPTER_FLY_TIME = 6.2 * 60; // 6.2 seconds in frames (~60fps)
  const INVINCIBILITY_TIME = 1.3 * 60; // 1.3 seconds invincibility after drop

  // Player State
  let player = {
    x: 80,
    y: FLOOR_Y - PLAYER_SIZE,
    width: PLAYER_SIZE,
    height: PLAYER_SIZE,
    vy: 0,
    onGround: true,
    forceField: false,
    flying: false,
    flyTimer: 0,
    invincibleTimer: 0,
  };

  // Game State
  let spikes = [];
  let forceFields = [];
  let helicopters = [];
  let frameCount = 0;
  let score = 0;
  let highScore = 0;
  let gameRunning = false;
  let speed = 4; // ground speed

  // Load high score from localStorage
  if(localStorage.getItem('endlessDashHighScore')) {
    highScore = Number(localStorage.getItem('endlessDashHighScore'));
  }

  // Utility funcs
  function rectsOverlap(r1, r2) {
    return !(r2.x > r1.x + r1.width ||
             r2.x + r2.width < r1.x ||
             r2.y > r1.y + r1.height ||
             r2.y + r2.height < r1.y);
  }

  // Spawn spikes, force fields, helicopters periodically
  function spawnObjects() {
    if(frameCount % SPAWN_INTERVAL === 0) {
      // Randomly choose what to spawn: mostly spikes, sometimes force fields or helicopters
      const rand = Math.random();
      if(rand < 0.7) {
        // Spawn spike
        spikes.push({
          x: W + 20,
          y: FLOOR_Y - 20,
          width: 20,
          height: 20,
        });
      } else if(rand < 0.85) {
        // Spawn force field power-up
        forceFields.push({
          x: W + 20,
          y: FLOOR_Y - 50,
          width: 25,
          height: 25,
        });
      } else {
        // Spawn helicopter a bit farther down
        helicopters.push({
          x: W + 60,
          y: FLOOR_Y - 100,
          width: 50,
          height: 30,
          active: true,
        });
      }
    }
  }

  // Reset game state
  function resetGame() {
    player = {
      x: 80,
      y: FLOOR_Y - PLAYER_SIZE,
      width: PLAYER_SIZE,
      height: PLAYER_SIZE,
      vy: 0,
      onGround: true,
      forceField: false,
      flying: false,
      flyTimer: 0,
      invincibleTimer: 0,
    };
    spikes = [];
    forceFields = [];
    helicopters = [];
    frameCount = 0;
    score = 0;
    speed = 4;
  }

  // Draw functions
  function drawPlayer() {
    // Draw force field if active
    if(player.forceField) {
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.fillStyle = 'blue';
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  function drawSpike(spike) {
    ctx.fillStyle = 'red';
    // spike shape ^
    ctx.beginPath();
    ctx.moveTo(spike.x, spike.y + spike.height);
    ctx.lineTo(spike.x + spike.width / 2, spike.y);
    ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
    ctx.closePath();
    ctx.fill();
  }

  function drawForceField(ff) {
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(ff.x + ff.width/2, ff.y + ff.height/2, ff.width/2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawHelicopter(heli) {
    ctx.fillStyle = 'gray';
    ctx.fillRect(heli.x, heli.y, heli.width, heli.height);
    // blades
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(heli.x + heli.width/2, heli.y);
    ctx.lineTo(heli.x + heli.width/2, heli.y - 20);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(heli.x + heli.width/2 - 15, heli.y - 10);
    ctx.lineTo(heli.x + heli.width/2 + 15, heli.y - 10);
    ctx.stroke();
  }

  function drawFloor() {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, FLOOR_Y, W, H - FLOOR_Y);
  }

  function drawScore() {
    scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
  }

  // Game loop
  function gameLoop() {
    if(!gameRunning) return;

    frameCount++;
    ctx.clearRect(0, 0, W, H);

    // Update player
    if(player.flying) {
      player.flyTimer--;
      // Fly up a bit
      player.y = FLOOR_Y - PLAYER_SIZE - 60;
      if(player.flyTimer <= 0) {
        player.flying = false;
        player.invincibleTimer = INVINCIBILITY_TIME;
      }
    } else {
      if(player.invincibleTimer > 0) player.invincibleTimer--;

      // Gravity
      player.vy += GRAVITY;
      player.y += player.vy;

      if(player.y > FLOOR_Y - PLAYER_SIZE) {
        player.y = FLOOR_Y - PLAYER_SIZE;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }
    }

    // Move spikes left
    spikes.forEach((spike, i) => {
      spike.x -= speed;

      // Remove offscreen spikes
      if(spike.x + spike.width < 0) spikes.splice(i, 1);
    });

    // Move force fields left
    forceFields.forEach((ff, i) => {
      ff.x -= speed;
      if(ff.x + ff.width < 0) forceFields.splice(i, 1);
    });

    // Move helicopters left
    helicopters.forEach((heli, i) => {
      heli.x -= speed;
      if(heli.x + heli.width < 0) helicopters.splice(i, 1);
    });

    // Check collisions
    if(player.invincibleTimer === 0) {
      // Check spike collisions
      for(let spike of spikes) {
        if(rectsOverlap(player, spike)) {
          if(player.forceField) {
            // lose force field, survive
            player.forceField = false;
            // remove spike (optional)
            // spikes.splice(spikes.indexOf(spike),1);
          } else {
            // Game over
            endGame();
            return;
          }
        }
      }
    }

    // Check force field pickups
    for(let i = 0; i < forceFields.length; i++) {
      if(rectsOverlap(player, forceFields[i])) {
        player.forceField = true;
        forceFields.splice(i, 1);
        break;
      }
    }

    // Check helicopter pickups
    if(!player.flying) {
      for(let i = 0; i < helicopters.length; i++) {
        if(rectsOverlap(player, helicopters[i]) && !player.flying) {
          // Start flying
          player.flying = true;
          player.flyTimer = HELICOPTER_FLY_TIME;
          helicopters.splice(i, 1);
          break;
        }
      }
    }

    // Draw everything
    drawFloor();
    spikes.forEach(drawSpike);
    forceFields.forEach(drawForceField);
    helicopters.forEach(drawHelicopter);
    drawPlayer();

    // Update score
    score += 0.1;
    drawScore();

    // Spawn new objects
    spawnObjects();

    // Increase speed gradually every 5 seconds (~300 frames)
    if(frameCount % 300 === 0) {
      speed *= 1.05; // increase speed by 5%
    }

    requestAnimationFrame(gameLoop);
  }

  // Start game
  function startGame() {
    resetGame();
    homeScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    scoreDisplay.style.display = 'block';

    // Show jump button on mobile devices
    if(window.innerWidth <= 768) {
      jumpButton.style.display = 'block';
    } else {
      jumpButton.style.display = 'none';
    }

    gameRunning = true;
    gameLoop();
  }

  // End game
  function endGame() {
    gameRunning = false;
    scoreDisplay.style.display = 'none';

    // Save high score
    if(score > highScore) {
      highScore = score;
      localStorage.setItem('endlessDashHighScore', Math.floor(highScore));
    }

    finalScoreText.textContent = `Score: ${Math.floor(score)}`;
    highScoreText.textContent = `High Score: ${Math.floor(highScore)}`;
    gameOverScreen.style.display = 'flex';

    jumpButton.style.display = 'none';
  }

  // Handle jump
  function jump() {
    if(!gameRunning) return;
    if(player.onGround || player.flying) {
      if(!player.flying) {
        player.vy = JUMP_VEL;
        player.onGround = false;
      }
    }
  }

  // Keyboard input
  window.addEventListener('keydown', e => {
    if(e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      jump();
    }
  });

  // Touch jump button
  jumpButton.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  });
  jumpButton.addEventListener('mousedown', e => {
    e.preventDefault();
    jump();
  });

  // Button clicks
  startBtn.addEventListener('click', () => {
    startGame();
  });
  returnHomeBtn.addEventListener('click', () => {
    gameOverScreen.style.display = 'none';
    homeScreen.style.display = 'flex';
  });

  // Adjust jump button on resize
  window.addEventListener('resize', () => {
    if(gameRunning && window.innerWidth <= 768) {
      jumpButton.style.display = 'block';
    } else {
      jumpButton.style.display = 'none';
    }
  });
})();
</script>

</body>
</html>
